//
// Generated by Coral
// Generated from IDLImplementation
//

import Foundation
import LoggerAPI

internal class NamedItemHolder
    {
    public var isContext:Bool
        {
        return(false)
        }
    }

internal class ObjectHolder:NamedItemHolder
    {
    public var object:CORBA_Object
    
    init(object:CORBA_Object)
        {
        self.object = object
        }
    }

internal class ContextHolder:NamedItemHolder
    {
    public var context:CosNaming_NamingContext
    
    public override var isContext:Bool
        {
        return(true)
        }
    
    init(context:CosNaming_NamingContext)
        {
        self.context = context
        }
    }

public class CosNaming_NamingContext_Implementation:Implementation,CosNaming_NamingContext
    {
    public static let rootContext = CosNaming_NamingContext_Implementation()
    
    private var name:String = ""
    private var entries:[String:NamedItemHolder] = [:]
    private var parentContext:CosNaming_NamingContext_Implementation?
    
    public override init()
        {
        super.init()
        self.interfaceId = "CosNaming::NamingContext"
        CORBA.orb.registerBOA(CosNaming_NamingContext_BOA.self,forInterfaceId:"CosNaming::NamingContext")
        CORBA.orb.registerImplementation(self,forObjectId: self.objectId)
        }

    private var compoundName:[String] 
        {
        if parentContext == nil
            {
            return([])
            }
        var theName = parentContext!.compoundName
        theName.append(self.name)
        return(theName)
        }
        
    public required init(host:String,port:Int,objectId:String,interfaceId:InterfaceId)
        {
        super.init(host:host,port:port,objectId:objectId,interfaceId:interfaceId)
        }
    
    private func nameAsString(name:CosNaming_Name) -> String
        {
        return(name.map{$0.id}.joined(separator: "->"))
        }
    
    // NotFound,CannotProceed,InvalidName
    public func resolve(n: CosNaming_Name) throws -> CORBA_Object?
        {
        Log.verbose("Resolve(\(nameAsString(name:n)))")
        guard n.count > 0 else
            {
            throw(CosNaming_NamingContext_NotFound(why: .missing_node, rest_of_name: n))
            }
        let firstName = n.first!.id
        if n.count == 1
            {
            let entry = entries[firstName]
            if entry == nil
                {
                throw(CosNaming_NamingContext_NotFound(why: .missing_node, rest_of_name: n))
                }
            if entry!.isContext
                {
                return((entry as! ContextHolder).context)
                }
            else
                {
                return((entry as! ObjectHolder).object)
                }
            }
        else
            {
            if let entry = entries[firstName],entry.isContext
                {
                return(try (entry as! ContextHolder).context.resolve(n: Array(n.dropFirst())))
                }
            else
                {
                throw(CosNaming_NamingContext_NotFound(why: .missing_node, rest_of_name: n))
                }
            }
        }

    // NotFound,CannotProceed,InvalidName,AlreadyBound
    public func bind_context(n: CosNaming_Name,naming_context: CosNaming_NamingContext?) throws -> Void
        {
        guard let naming_context = naming_context else
            {
            Log.error("naming_context passed into bind_context is nil \(n)")
            throw(CosNaming_NamingContext_CannotProceed(cxt: self, rest_of_name: n))
            }
        Log.verbose("Bind_context(\(nameAsString(name:n)))")
        guard n.count > 0 else
            {
            throw(CosNaming_NamingContext_NotFound(why: .missing_node, rest_of_name: n))
            }
        let first = n[0].id
        if n.count == 1
            {
            entries[first] = ContextHolder(context:naming_context)
            let actualContext = (CORBA.orb as! NeonORB).materialize(object:naming_context) as! CosNaming_NamingContext_Implementation
            actualContext.parentContext = self
            }
        else
            {
            if let entry = entries[first],entry.isContext
                {
                try (entry as! ContextHolder).context.bind_context(n: Array(n.dropFirst()),naming_context:naming_context)
                }
            else
                {
                throw(CosNaming_NamingContext_NotFound(why: .missing_node, rest_of_name: n))
                }
            }
        }
    
    // 
    public func new_context() throws -> CosNaming_NamingContext?
        {
        return(CosNaming_NamingContext_Implementation())
        }
    
    // NotFound,AlreadyBound,CannotProceed,InvalidName
    public func bind_new_context(n: CosNaming_Name) throws -> CosNaming_NamingContext?
        {
        let context = CosNaming_NamingContext_Implementation()
        context.parentContext = self
        try self.bind_context(n:n,naming_context:context)
        return(context)
        }
    
    // NotFound,CannotProceed,InvalidName
    public func unbind(n: CosNaming_Name) throws -> Void
        {
        guard n.count > 0 else
            {
            throw(CosNaming_NamingContext_NotFound(why: .missing_node, rest_of_name: n))
            }
        let first = n[0].id
        if n.count == 1
            {
            entries[first] = nil
            return
            }
        else
            {
            if let entry = entries[first],entry.isContext
                {
                try (entry as! ContextHolder).context.unbind(n: Array(n.dropFirst()))
                }
            else
                {
                throw(CosNaming_NamingContext_NotFound(why: .missing_node, rest_of_name: n))
                }
            }
        }
    // NotFound,CannotProceed,InvalidName,AlreadyBound
    public func bind(n: CosNaming_Name,object: CORBA_Object?) throws -> Void
        {
        guard let object = object else
            {
            Log.error("Object passed into bind is nil \(n)")
            throw(CosNaming_NamingContext_CannotProceed(cxt: self, rest_of_name: n))
            }
        Log.verbose("Bind(\(nameAsString(name:n)))")
        guard n.count > 0 else
            {
            throw(CosNaming_NamingContext_NotFound(why: .missing_node, rest_of_name: n))
            }
        let first = n[0].id
        if n.count == 1
            {
            entries[first] = ObjectHolder(object:object)
            return
            }
        else
            {
            if let entry = entries[first],entry.isContext
                {
                try (entry as! ContextHolder).context.bind(n: Array(n.dropFirst()),object:object)
                }
            else
                {
                throw(CosNaming_NamingContext_NotFound(why: .missing_node, rest_of_name: n))
                }
            }
        }
    
    // NotEmpty
    public func destroy() throws -> Void
        {
        CORBA.orb.deregisterImplementation(self)
        }
    
    // NotFound,CannotProceed,InvalidName
    public func rebind_context(n: CosNaming_Name,naming_context: CosNaming_NamingContext?) throws -> Void
        {
        guard let naming_context = naming_context else
            {
            Log.error("naming_context in rebind_context is nil \(n)")
            throw(CosNaming_NamingContext_CannotProceed(cxt: self, rest_of_name: n))
            }
        guard n.count > 0 else
            {
            throw(CosNaming_NamingContext_NotFound(why: .missing_node, rest_of_name: n))
            }
        let first = n[0].id
        if n.count == 1
            {
            entries[first] = ContextHolder(context:naming_context)
            let actualContext = (CORBA.orb as! NeonORB).materialize(object:naming_context) as! CosNaming_NamingContext_Implementation
            actualContext.parentContext = self
            return
            }
        else
            {
            if let entry = entries[first],entry.isContext
                {
                try (entry as! ContextHolder).context.rebind_context(n: Array(n.dropFirst()),naming_context:naming_context)
                }
            throw(CosNaming_NamingContext_NotFound(why: .missing_node, rest_of_name: n))
            }
        }
    
    // NotFound,CannotProceed,InvalidName
    public func rebind(n: CosNaming_Name,object: CORBA_Object?) throws -> Void
        {
        guard let object = object else
            {
            Log.error("Object passed into rebind is nil \(n)")
            throw(CosNaming_NamingContext_CannotProceed(cxt: self, rest_of_name: n))
            }
        guard n.count > 0 else
            {
            throw(CosNaming_NamingContext_NotFound(why: .missing_node, rest_of_name: n))
            }
        let first = n[0].id
        if n.count == 1
            {
            entries[first] = ObjectHolder(object:object)
            return
            }
        else
            {
            if let entry = entries[first],entry.isContext
                {
                try (entry as! ContextHolder).context.rebind(n: Array(n.dropFirst()),object:object)
                }
            throw(CosNaming_NamingContext_NotFound(why: .missing_node, rest_of_name: n))
            }
        }
    
    // 
    public func list(how_many: UInt32,binding_list:inout CosNaming_BindingList,binding_iterator:inout CosNaming_BindingIterator?) throws -> Void
        {
        var list:[CosNaming_Binding] = []
        for (key,entry) in entries
            {
            let bindingName = self.compoundName.appending(key).asCosName()
            let bindingType = entry.isContext ? CosNaming_BindingType.ncontext : CosNaming_BindingType.nobject
            let bindingEntry = CosNaming_Binding(binding_name: bindingName, binding_type: bindingType)
            list.append(bindingEntry)
            }
        binding_list = list
        binding_iterator = nil
        }
    
    }
